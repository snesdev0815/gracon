#!/usr/bin/env python2.7

__author__ = "Matthias Nagler <matt@dforce.de>"
__url__ = ("dforce3000", "dforce3000.de")
__version__ = "0.1"

'''
reads tiled *.tmx map files, spits out level file

-actual steps:
  -inputfile: tmx xml file
  -assert: map "orthogonal", map "tilewidth" 8, map "tileheight" 8
  -fetch
    -map "width"
    -map "height"
    -each tileset
      -tileset "firstgid"
      -image "source"
      -image "trans"
    -each layer (keep order)
      -assert: layer "width" = map "width", layer "height" = map "height", data encoding=csv
      -property "name" = collision
      -data
    -each object
      -assert: name != ""
      -x
      -y
      -width
      -height
      -name
  -level may be written as binary file, but objects must definitely have their text reference preserved for proper linking later on.
    -writing asm textfile for each level is probably the wisest idea.
  -objects are not a complete tilemap, but just objects with position,size and parameters.
    -the game then expands these to a map in ram so that they can be loaded and subsequently erased once the screen scroll hits them.
    -parameters:
      -all property parameters are named and must be explicity defined in snes code for every object.
        -otherwise, no reliable association is possible.
        -when instanciating level objects, properties not specified in level will be set to 0.
        -properties set in level but not in code will be dismissed

Level format:

.enum 0
  LEVEL.MAGIC dw    ;"LV"
  LEVEL.NAME ds 16      ;ascii-name of level
  LEVEL.TILESIZE.X dw    ;width in tiles (min $20, max $2000)
  LEVEL.TILESIZE.Y dw    ;height in tiles (min $1c, max $2000)
  LEVEL.MAP.COUNT db    ;number of maps in this level: 3-6 (collision,object,1-4 bg)
  LEVEL.OBJECT.COUNT db ;number of objects on map
  LEVEL.POINTER.PALETTE dw  ;relative pointer to color palette
  LEVEL.POINTER.TILESET dw  ;relative pointer to tileset
  LEVEL.POINTER.OBJECTS dw  ;relative pointer to tileset
  LEVEL.POINTER.OBJMAP ds 3
  LEVEL.POINTER.TILEMAP ds 3  ;absolute pointer to actual tiles used across all levels
  LEVEL.POINTER.METAMAP ds 3  ;repeated for LEVEL.MAP.COUNT. absolute pointer to each 2x2 meta layer map
  
  (palette)
  (tiles)
  (objects{
    LEVEL.OBJECT.CLASS.ID dw
    LEVEL.OBJECT.POSITION.X dw
    LEVEL.OBJECT.POSITION.Y dw
    LEVEL.OBJECT.SIZE.X dw
    LEVEL.OBJECT.SIZE.Y dw
    LEVEL.OBJECT.PARAMETER.0 dw
    LEVEL.OBJECT.PARAMETER.1 dw
    LEVEL.OBJECT.PARAMETER.2 dw
  })
  (map{
    LEVEL.OBJECT.TILE.CONFIG db
    LEVEL.OBJECT.TILE.CONFIG db
  })
    
Heres the text output format the level gets written to:
;autogenerated level file, do not edit manually


level format & layout:
-2-4 layer maps of metatiles (bg0,bg1,status,collision), 0x2000 bytes each
  -each entry consists of word-sized index into metatile list. max index: $ffff
-metatile list: up to 0xE000 bytes
-objmap: 128*120: 0x3c00

-total size per level: 0x19C00

'''

import os
import re
import sys
import math
import string
import logging
import xml.dom.minidom
import graconUserOptions
import graconGfx

META_TILESIZE = 16

TILED_ID_FLIP_DIAGONAL = 0x20000000
TILED_ID_FLIP_Y = 0x40000000
TILED_ID_FLIP_X = 0x80000000

METAMAP_SIZE_MAX = 0xbc00

logging.basicConfig( level=logging.ERROR, format='%(message)s')

options = {}

def main():
  options = graconUserOptions.Options( sys.argv, {
	'infile'		: {
	  'value'			: '',
	  'type'			: 'str'
	  },
	'outfolder'		: {
	  'value'			: '.',
	  'type'			: 'str'
	  },
    'outfile'     : {
      'value'           : '',
      'type'            : 'str'
      },
    'outfilebase'     : {
      'value'           : '',
      'type'            : 'str'
      },            
    'palettes'      : {
      'value'           : 8,
      'type'            : 'int',
      'max'         : 8,
      'min'         : 0
      },
    'transcol'  : {
      'value'           : 0xff00ff,
      'type'            : 'hex',
      'max'         : 0xffffff,
      'min'         : 0x0
      },      
    'tilesizex' : {
      'value'           : 8,
      'type'            : 'int',
      'max'         : 16,
      'min'         : 8
      },
    'tilesizey' : {
      'value'           : 8,
      'type'            : 'int',
      'max'         : 16,
      'min'         : 8
      },
    'optimize'  : {
      'value'           : True,
      'type'            : 'bool'
      },
    'directcolor'  : {
      'value'           : False,
      'type'            : 'bool'
      },      
    'tilethreshold' : {
      'value'           : 1,
      'type'            : 'int',
      'max'         : 0xffff,
      'min'         : 0
      },
    'maxtiles' : {
      'value'           : 0x3ff,
      'type'            : 'int',
      'max'         : 0x3ff,
      'min'         : 0
      },          
    'bpp'       : {
      'value'           : 4,
      'type'            : 'int',
      'max'         : 8,
      'min'         : 1
      },
    'mode'      : {
      'value'           : 'bg',
      'type'            : 'str'
      },
    'resolutionx'   : {
      'value'           : 256,
      'type'            : 'int',
      'max'         : 0xffff,
      'min'         : 1
      },      
    'resolutiony'   : {
      'value'           : 224,
      'type'            : 'int',
      'max'         : 0xffff,
      'min'         : 1
      },
    'refpalette'        : {
      'value'           : '',
      'type'            : 'str'
      },
    'verify'        : {
      'value'           : False,
      'type'            : 'bool'
    },
    'dump'        : {
      'value'           : False,
      'type'            : 'bool'
    },    
  'bigtilethreshold' : {  #number of empty tiles to allow when parsing big mode tiles (usually 32x32 sprites)
    'value'     : 2,
    'type'      : 'int',
    'max'     : 16,
    'min'     : 0
    },
  'forcePalette'        : {
      'value'           : False,
      'type'            : 'bool'
    },
  'collisionTileModifiable' : {  #all collision tiles above this are potentially Modifiable at runtime and therefore require UNIQUE meta tiles
    'value'     : 0,  #0 means: disable Modifiable tiles alltogether
    'type'      : 'int',
    'max'     : 255,
    'min'     : 0
    }
  })

  options.set('transcol', graconGfx.Color(graconGfx.getColorTuple(options.get('transcol'))))
  
  sys.setrecursionlimit(10000)
  
  singleTileSize = options.get('tilesizex') * options.get('tilesizey') / 2

  options.set('outfilebase', options.get('outfile'))
  
  logging.debug('xml parse start')
  if not os.path.exists(options.get('outfolder')):
    logging.debug('creating out-folder' % options.get('outfolder'))
    os.makedirs(options.get('outfolder'))

  if not os.path.exists(options.get('infile')):
    logging.error( 'Error, input file "%s" is nonexistant.' % options.get('infile') )
    sys.exit(1)
       
  levelXmlFile = open(options.get('infile'), 'rb')

  refPalette = None
  if os.path.exists('%s.palette.png' % options.get('infile')):
    options.set('refpalette', '%s.palette.png' % options.get('infile'))
    logging.info('using reference palette file %s.palette.png...' % options.get('infile'))
    #set transparent color to first color in reference palette
    refPalette = graconGfx.getReferencePaletteImage(options)
    options.set('transcol', refPalette['pixels'][0][0])

    logging.debug("transparent color now %x" % options.get('transcol').getRGB())
  
  try:
    xmlDom = xml.dom.minidom.parseString(levelXmlFile.read())
  except xml.parsers.expat.ExpatError:
    logging.error('unable to parse xml file %s.' % options.get('infile'))
    sys.exit(1)

  mapElement = xmlDom.getElementsByTagName('map')[0]
  mapInfo = {
    'width' : mapElement.getAttribute('width'),
    'height' : mapElement.getAttribute('height'),
    'name' : options.get('infile')

  }

  if not 'orthogonal' == mapElement.getAttribute('orientation'):
    logging.error( 'Error, level orientation is not orthogonal' )
    sys.exit(1)

  if not str(options.get('tilesizex')) == mapElement.getAttribute('tilewidth'):
    logging.error( 'Error, tile width must be %s' % options.get('tilesizex'))
    sys.exit(1)

  if not str(options.get('tilesizey')) == mapElement.getAttribute('tileheight'):
    logging.error( 'Error, tile height must be %s' % options.get('tilesizey'))
    sys.exit(1)

  #if not options.get('mapwidth') == int(mapInfo['width']):
  if not int(mapInfo['width']) in (32,64,128,256,512,1024,2048):
    logging.error( 'Error, map width must be multiple of 32, is %s' % mapInfo['width'])
    sys.exit(1)

  if 0x10000 < int(mapInfo['width'])*int(mapInfo['height']):
    logging.error( 'Error, map width*height is %s, must not exceed $s' % (int(mapInfo['width'])*int(mapInfo['height']), 0x10000))
    sys.exit(1)


  min_x = 0
  min_y = 0
  max_x = int(mapInfo['width'])
  max_y = int(mapInfo['height'])
  scrollfactor_bg_lower = 0
  scrollfactor_bg_upper = 0
  scrollfactor_bg_status = 0
  hidden_treasure_count = 0
  timer_gold = 0
  echo_volume = "ECHO.VOLUME.MUTE"
  cgadsubConfig = 0
  isSubLevel = 0
  colorAdditionConfig = 0
  miscFlags = 0
  flagsScrollLower = 0
  flagsScrollUpper = 0
  flagsScrollStatus = 0
  scriptLoad = "none"
  timer = "TIMER.NONE"
  song = "Song.none.PTR"
  mapmode = "LEVEL.MODE.NORMAL"
  
  for propertyElement in mapElement.getElementsByTagName('property'):
    if 'max.x' == propertyElement.getAttribute('name'):
      max_x = int(propertyElement.getAttribute('value'))
    elif 'max.y' == propertyElement.getAttribute('name'):
      max_y = int(propertyElement.getAttribute('value'))
    elif 'min.x' == propertyElement.getAttribute('name'):
      min_x = int(propertyElement.getAttribute('value'))
    elif 'min.y' == propertyElement.getAttribute('name'):
      min_y = int(propertyElement.getAttribute('value'))
    elif 'scrollfactor.bg.lower' == propertyElement.getAttribute('name'):
      scrollfactor_bg_lower = int(propertyElement.getAttribute('value'))
    elif 'scrollfactor.bg.upper' == propertyElement.getAttribute('name'):
      scrollfactor_bg_upper = int(propertyElement.getAttribute('value'))
    elif 'scrollfactor.bg.status' == propertyElement.getAttribute('name'):
      scrollfactor_bg_status = int(propertyElement.getAttribute('value'))
    elif 'hidden_treasure.count' == propertyElement.getAttribute('name'):
      hidden_treasure_count = int(propertyElement.getAttribute('value'))            
    elif 'song' == propertyElement.getAttribute('name'):
      song = propertyElement.getAttribute('value')
    elif 'map.mode' == propertyElement.getAttribute('name'):
      mapmode = propertyElement.getAttribute('value')
    elif 'sublevel' == propertyElement.getAttribute('name'):
      isSubLevel = propertyElement.getAttribute('value')
    elif 'cgadsub' == propertyElement.getAttribute('name'):
      cgadsubConfig = propertyElement.getAttribute('value')
    elif 'color_addition' == propertyElement.getAttribute('name'):
      colorAdditionConfig = propertyElement.getAttribute('value')
    elif 'flags.misc' == propertyElement.getAttribute('name'):
      miscFlags = propertyElement.getAttribute('value')
    elif 'flags.scroll.lower' == propertyElement.getAttribute('name'):
      flagsScrollLower = propertyElement.getAttribute('value')
    elif 'flags.scroll.upper' == propertyElement.getAttribute('name'):
      flagsScrollUpper = propertyElement.getAttribute('value')
    elif 'flags.scroll.status' == propertyElement.getAttribute('name'):
      flagsScrollStatus = propertyElement.getAttribute('value')
    elif 'timer.gold' == propertyElement.getAttribute('name'):
      timer_gold = propertyElement.getAttribute('value')
    elif 'echo.volume' == propertyElement.getAttribute('name'):
      echo_volume = propertyElement.getAttribute('value')
    elif 'script.load' == propertyElement.getAttribute('name'):
      scriptLoad = propertyElement.getAttribute('value')
    elif 'timer' == propertyElement.getAttribute('name'):
      timer = propertyElement.getAttribute('value')

  logging.debug("map mode now %s" % mapmode)

  if min_x >= max_x or max_x > int(mapInfo['width']) or min_y >= max_y or max_y > int(mapInfo['height']):
    logging.error( 'Error, map boundary out of range. width: %s, height: %s, left:%s, right:%s, top: %s, bottom: %s' % (int(mapInfo['width']), int(mapInfo['height']), min_x, max_x, min_y, max_y))
    sys.exit(1)
  
  bgTilesets = []
  collisionTilesets = []
  statusTilesets = []
  for tilesetElement in mapElement.getElementsByTagName('tileset'):
    image = tilesetElement.getElementsByTagName('image')[0]
    for propertyElement in tilesetElement.getElementsByTagName('property'):
      if 'type' == propertyElement.getAttribute('name'):
        if 'bg' == propertyElement.getAttribute('value'):
          bgTilesets.append({
            'firstgid' : tilesetElement.getAttribute('firstgid'),
            'filename' : image.getAttribute('source'),
            'transcol' : image.getAttribute('trans')
          })
        elif 'collision' == propertyElement.getAttribute('value'):
          collisionTilesets.append({
            'firstgid' : tilesetElement.getAttribute('firstgid'),
            'filename' : image.getAttribute('source'),
            'transcol' : image.getAttribute('trans')
          })
        elif 'status' == propertyElement.getAttribute('value'):
          statusTilesets.append({
            'firstgid' : tilesetElement.getAttribute('firstgid'),
            'filename' : image.getAttribute('source'),
            'transcol' : image.getAttribute('trans')
          })                

  if not 1 == len(bgTilesets) or not 1 == len(collisionTilesets):
    logging.error( 'There must be exactly one bg tileset and exactly one collision tileset in map %s (set tileset property "type" to "bg" or "collision")' % mapInfo['name'])
    sys.exit(1)

  bgLayers = []
  statusLayers = []
  collisionLayer = False
  slopeLayer = False
  elevationLayer = False
  layerFlags = 0
  
  
  logging.info('Parsing BG layers...')
  for layerElement in mapElement.getElementsByTagName('layer'):
    layerOrder = 0
    if not mapInfo['width'] == layerElement.getAttribute('width'):
      logging.error( 'Error, layer %s width doesnt match map width' % layerElement.getAttribute('name'))
      sys.exit(1)
    if not mapInfo['height'] == layerElement.getAttribute('height'):
      logging.error( 'Error, layer %s height doesnt match map height' % layerElement.getAttribute('name') )
      sys.exit(1)
    layerName = layerElement.getAttribute('name')

    if re.search('front', layerName, re.I):
      layerOrder += 1
    if re.search('upper', layerName, re.I):
      layerOrder += 2
    logging.info('got layer %s, order %s' % (layerName, layerOrder))
    layerFound = False
    for propertyElement in layerElement.getElementsByTagName('property'):
      if 'type' == propertyElement.getAttribute('name'):
        if 'bg' == propertyElement.getAttribute('value'):
          bgLayers.append((layerOrder, getLayerData(layerElement)))
          layerFound = True

        if 'status' == propertyElement.getAttribute('value'):
          statusLayers.append(getLayerData(layerElement))
          layerFound = True

        elif 'collision' == propertyElement.getAttribute('value'):
          collisionLayer = getLayerData(layerElement)
          layerFound = True

        elif 'slope' == propertyElement.getAttribute('value'):
          slopeLayer = getLayerData(layerElement)
          layerFound = True

        elif 'elevation' == propertyElement.getAttribute('value'):
          elevationLayer = getLayerData(layerElement)
          layerFound = True

        #dummy, discard
        elif 'none' == propertyElement.getAttribute('value'):
          layerFound = True

    if not layerFound:
      logging.error( 'unsupported layer %s encountered, must be of type (bg/collision/status/slope/elevation) or(set layer property "type" to "bg" or "collision")' % layerElement.getAttribute('name'))
      sys.exit(1)

      
  if not collisionLayer:
    logging.error( 'map lacks collision layer (set layer property "type" to "collision")')
    sys.exit(1)

  '''
  if not slopeLayer:
    logging.error( 'map lacks slope layer (set layer property "type" to "slope")')
    sys.exit(1)

  if not elevationLayer:
    logging.error( 'map lacks elevation layer (set layer property "type" to "elevation")')
    sys.exit(1)
  '''
  bgLayers.sort(key=lambda layer: layer[0])

  bgLayers = map(lambda x: x[1], bgLayers)

  if 1 > len(bgLayers) or 4 < len(bgLayers):
    logging.error( 'map must have at least one and no more than 4 bg layers (set layer property "type" to "bg")')
    sys.exit(1)

  '''
  if not (len(collisionLayer['data']) == len(elevationLayer['data']) and len(collisionLayer['data']) == len(slopeLayer['data'])):
    logging.error( 'collision, slope and elevation layer of map must all have the same layer size')
    sys.exit(1)
  '''
  logging.info('Parsed %s BG layers.' % len(bgLayers))
  

  objects = []
  for objectElement in mapElement.getElementsByTagName('object'):
    if 8 > objectElement.getAttribute('x'):
      logging.error('map has with x-position < 8, aborting.')
      sys.exit(1)
      
    properties = []
    for propertyElement in objectElement.getElementsByTagName('property'):
      properties.append({
        'name' : propertyElement.getAttribute('name'),
        'value' : propertyElement.getAttribute('value'),
      })
    properties.append({
      'name' : 'pos.x',
      'value' : objectElement.getAttribute('x'),
    })
    properties.append({
      'name' : 'pos.y',
      'value' : objectElement.getAttribute('y'),
    })
    properties.append({
      'name' : 'size.x',
      'value' : objectElement.getAttribute('width'),
    })
    properties.append({
      'name' : 'size.y',
      'value' : objectElement.getAttribute('height'),
    })
    objects.append({
      'class' : objectElement.getAttribute('type'),
      'properties' : properties
    })

    #@todo: add defaults for specialized objects if it doesnt contain attributes (e.g. script=none for exit)
  if 128 < len(objects):
    logging.error('map has %s objects, 128 allowed' % len(objects))

    sys.exit(1)
  
  #parse bg tileset
  tileset = bgTilesets[0]
  bgTilesetFilename = tileset['filename'].replace('~WORKFILE', '')
  logging.info('Parsing bg tileset %s...' % bgTilesetFilename)
  inputImage = graconGfx.getInputImage(options, "%s/%s" % (os.path.dirname(options.get('infile')), bgTilesetFilename))
  convertedTileset = graconGfx.parseTiles(inputImage, options)['normal']
  
  #strip (dummy-replace) all tiles not explicitly referenced in current map
  usedTiles = getUsedTiles(bgLayers, tileset)
  dummyTile = convertedTileset[0]
  convertedTileset = [(tile if tile['id'] in usedTiles else {
    'id' : tile['id'],
    'palette' : dummyTile['palette'],
    'pixel' : dummyTile['pixel'],
    'pixhash' : dummyTile['pixhash'],
    'refId' : dummyTile['refId'],
    'x' : tile['x'],
    'xMirror' : dummyTile['xMirror'],
    'y' : tile['y'],
    'yMirror' : dummyTile['yMirror']
  }) for tile in convertedTileset]
  logging.info('Got %s tiles total, parsing global palette...' % len(convertedTileset))
  palette = graconGfx.fetchGlobalPaletteTileRelative(convertedTileset, options)  
  palette = graconGfx.augmentOutIds(palette)
  logging.info('Optimizing tileset (merging similar-looking & mirrored tiles), this may take ages...')
  convertedTileset = graconGfx.augmentOutIds(graconGfx.optimizeTilesNew(graconGfx.palettizeTiles(convertedTileset, palette, options), None, options))
  
  #insert dummy tile 0:
  emptyTile = {
    'indexedPixel': [[0 for x in range(options.get('tilesizex'))] for y in range(options.get('tilesizey'))],
    'refId': None,
    'id': -1,
    'palette':{'refId':None, 'id':-1},
    'x':0,
    'xMirror': False,
    'y':0,
    'yMirror': False,
    'outId':0
  }
  
  #pp.pprint(convertedTileset)

  tilecount = len([tile for tile in convertedTileset if None == tile['refId']])
  if 1024 < tilecount:
    logging.error( 'map tileset has %s tiles. maximum allowed quantity is 1024' % tilecount)
    sys.exit(1)

  logging.info('Tileset reduced from %s to %s tiles...' % (len(convertedTileset), tilecount))
  logging.info('Applying tileset to layers...')
  bgLayers = convertLayerTilemaps(bgLayers, tileset, convertedTileset, palette, options, 1)

  logging.debug(["bg layer status map size", len(statusLayers)])

  bgLayers = combineBgLayers(bgLayers)

  logging.debug(["got layer count", len(bgLayers)])
  ModifiableLayers = [0]
  if 0 == scrollfactor_bg_upper:
    ModifiableLayers.append(len(bgLayers)-1)
  if 0 == scrollfactor_bg_lower:
    ModifiableLayers.append(len(bgLayers)-2)
  if 0 == scrollfactor_bg_status:
    ModifiableLayers.append(len(bgLayers)-3)

  bgPalette = palette
  bgPaletteStream = graconGfx.getPaletteWriteStream(bgPalette, options)
  bgTilesetStream = graconGfx.getTileWriteStream([emptyTile] + convertedTileset, options)
  bgTilesetStreamHash = 'hash%x' % math.fabs(hash(str(bgTilesetStream)))
  
  logging.info('Merged BG layers, got %s total...' % len(bgLayers))

  if 1 <= len(bgLayers) and 0 != reduce(lambda x,y: x+y, bgLayers[0]['data']):
    layerFlags = layerFlags | 1
  if 2 == len(bgLayers) and 0 != reduce(lambda x,y: x+y, bgLayers[1]['data']):
    layerFlags = layerFlags | 2
    layerBuffer0 = bgLayers[1]
    layerBuffer1 = bgLayers[0]
    bgLayers[0] = layerBuffer0
    bgLayers[1] = layerBuffer1


  if 1 <= len(statusLayers):
    if not 1 == len(statusTilesets):
      logging.error( 'There must be exactly one status tileset in map %s (set tileset property "type" to "status")' % mapInfo['name'])
      sys.exit(1)
    
    #parse status tileset
    statusTileset = statusTilesets[0]
    
    options.set('refpalette', '')
    options.set('transcol', graconGfx.Color(graconGfx.getColorTuple(0xff00ff)))

    
    if os.path.exists('%s.palette_status.png' % options.get('infile')):
      options.set('refpalette', '%s.palette_status.png' % options.get('infile'))
      #set transparent color to first color in reference palette
      statusRefPalette = graconGfx.getReferencePaletteImage(options)
      options.set('transcol', statusRefPalette['pixels'][0][0])
    
    logging.info('Parsing status tileset...')
    options.set('bpp', 2)
    options.set('palettes', 4)
    statusInputImage = graconGfx.getInputImage(options, "%s/%s" % (os.path.dirname(options.get('infile')), statusTileset['filename']))
    convertedStatusTileset = graconGfx.parseTiles(statusInputImage, options)['normal']
    
    #strip (dummy-replace) all tiles not explicitly referenced in current map
    usedStatusTiles = getUsedTiles(statusLayers, statusTileset)
        
    dummyStatusTile = convertedStatusTileset[0]
    convertedStatusTileset = [(tile if tile['id'] in usedStatusTiles else {
      'id' : tile['id'],
      'palette' : dummyStatusTile['palette'],
      'pixel' : dummyStatusTile['pixel'],
      'pixhash' : dummyStatusTile['pixhash'],
      'refId' : dummyStatusTile['refId'],
      'x' : tile['x'],
      'xMirror' : dummyStatusTile['xMirror'],
      'y' : tile['y'],
      'yMirror' : dummyStatusTile['yMirror']
    }) for tile in convertedStatusTileset]
    logging.info('Got %s tiles total, parsing global palette...' % len(convertedStatusTileset))
    statusPalette = graconGfx.fetchGlobalPaletteTileRelative(convertedStatusTileset, options)  
    statusPalette = graconGfx.augmentOutIds(statusPalette)
    logging.info('Optimizing tileset (merging similar-looking & mirrored tiles), this may take ages...')
    convertedStatusTileset = graconGfx.augmentOutIds(graconGfx.optimizeTilesNew(graconGfx.palettizeTiles(convertedStatusTileset, statusPalette, options), None, options))
    tilecount = len([tile for tile in convertedStatusTileset if None == tile['refId']])
    if 1024 < tilecount:
      logging.error( 'map status tileset has %s tiles. maximum allowed quantity is 1024' % tilecount)
      sys.exit(1)

    logging.info('Status Tileset reduced from %s to %s tiles...' % (len(convertedStatusTileset), tilecount))
    logging.info('Applying tileset to layers...')
    statusLayers = convertLayerTilemaps(statusLayers, statusTileset, convertedStatusTileset, statusPalette, options, 2)

    statusPaletteStream = graconGfx.getPaletteWriteStream(statusPalette, options)
    statusTilesetStream = graconGfx.getTileWriteStream(convertedStatusTileset, options)
    statusTilesetStreamHash = 'hash%x' % math.fabs(hash(str(statusTilesetStream)))
    
    options.set('bpp', 4)
    options.set('palettes', 8)

  logging.info('Combining layers...')
  statusLayer = combineBgLayers(statusLayers)
  logging.debug(["bg layer status map size after combine", len(statusLayer)]) 
  if 1 == len(statusLayer):
      statusLayer = statusLayer[0]
  else:
      statusLayer = False

  if False != statusLayer and 0 != reduce(lambda x,y: x+y, statusLayer['data']):
    layerFlags = layerFlags | 4

  ModifiableIndexes = range(len(collisionLayer['data']))
  for tileId in range(len(collisionLayer['data'])):
    mode = max(0,(collisionLayer['data'][tileId] & ~(TILED_ID_FLIP_DIAGONAL | TILED_ID_FLIP_X | TILED_ID_FLIP_Y)) - int(collisionTilesets[0]['firstgid']))
    if 0 != options.get('collisionTileModifiable') and mode >= options.get('collisionTileModifiable'):
      ModifiableIndexes[tileId]  = True
    else:
      ModifiableIndexes[tileId]  = False
    
    if 255 < mode:
      logging.error( 'map collision layer tileID %s, x:%s,y:%s has illegal value %s. max allowed value is 255.' % (tileId, tileId % int(mapInfo['width']), math.floor(tileId/int(mapInfo['width'])), mode))
      sys.exit(1)

    collisionLayer['data'][tileId] = mode

  if statusLayer:
    bgLayers.append(statusLayer)
  metaLayers = list(bgLayers)
  metaLayers.insert(0, collisionLayer)
  
  logging.info('Getting meta tiles...')

  metaLayers = getMetaTilesAbsolute(metaLayers, int(mapInfo['width']), ModifiableIndexes, ModifiableLayers)

  if METAMAP_SIZE_MAX < len(metaLayers['tiles']):
    logging.error( 'map has %x metatile bytes. maximum allowed quantity is 0x%x' % (len(metaLayers['tiles']), METAMAP_SIZE_MAX))
    sys.exit(1)
  logging.info( 'map has %x metatile bytes.' % len(metaLayers['tiles']) )

  logging.info('Writing level files...')

  outFile = open(options.get('outfile'), 'w')
  
  levelName = os.path.split(options.get('infile'))[1].split('.')[0]
  outFile.write(';autogenerated level file, do not edit manually\n\n')
  outFile.write('.section "level.%s" superfree\n' % levelName)
  
  outFile.write('level.%s:\n' % levelName)
  
  outFile.write('.db "LV" ;magic\n')
  outFile.write('.db "%s" ;name\n' % ((levelName+"                ")[:16]))
  outFile.write('.dw %s ;map-size x\n' % mapInfo['width'])
  outFile.write('.dw %s ;map-size y\n' % mapInfo['height'])
  outFile.write('.dw %s ;left level border\n' % min_x)
  outFile.write('.dw %s ;top level border\n' % min_y)
  outFile.write('.dw %s ;right level border\n' % max_x)
  outFile.write('.dw %s ;bottom level border\n' % max_y)
  outFile.write('.db %s ;mapmode\n' % mapmode)
  outFile.write('.db %s ;isSubLevel\n' % isSubLevel)  
  outFile.write('.db %s ;song\n' % song)
  outFile.write('.db %s ;layer flags\n' % layerFlags)
  outFile.write('.dw %s ;lower layer animation flags\n' % flagsScrollLower)
  outFile.write('.dw %s ;upper layer animation flags\n' % flagsScrollUpper)
  outFile.write('.dw %s ;status layer animation flags\n' % flagsScrollStatus)
  outFile.write('.db %s ;cgadsub config\n' % cgadsubConfig)
  outFile.write('.db %s ;colorAddition config\n' % colorAdditionConfig)
  outFile.write('.dw %s ;misc config flags\n' % miscFlags)

  outFile.write('.db %s ;count of hidden treasures\n' % hidden_treasure_count)  
  outFile.write('.db %s ;scrollfactor lower layer\n' % scrollfactor_bg_lower)
  outFile.write('.db %s ;scrollfactor upper layer\n' % scrollfactor_bg_upper)
  outFile.write('.db %s ;scrollfactor status layer\n' % scrollfactor_bg_status)  
  
  outFile.write('.dw %s ;timer gold\n' % timer_gold)  
  outFile.write('.db %s ;echo volume\n' % echo_volume)
  outFile.write('.db %s ;timer mode \n' % timer)
  outFile.write('.dw %s ;loader script\n' % scriptLoad)

  outFile.write('.db %s ;number of layers in level\n' % (len(metaLayers['layers'])))
  outFile.write('.db %s ;number of objects in level\n' % len(objects))

  outFile.write('.dw %s ;absolute tileset pointer\n' % bgTilesetStreamHash)
  outFile.write('.db :%s ;absolute tileset pointer\n' % bgTilesetStreamHash)
  outFile.write('.dw %s ;tileset length\n' % len(bgTilesetStream))

  if not statusLayer:
    outFile.write('.dw 0 ;absolute statustileset pointer\n')
    outFile.write('.db 0 ;absolute statustileset pointer\n')
    outFile.write('.dw 0 ;statustileset length\n')
  else:
    outFile.write('.dw %s ;absolute statustileset pointer\n' % statusTilesetStreamHash)
    outFile.write('.db :%s ;absolute statustileset pointer\n' % statusTilesetStreamHash)
    outFile.write('.dw (%s.end - %s) ;statustileset length\n' % (statusTilesetStreamHash, statusTilesetStreamHash))
  
  outFile.write('.dw (level.%s.palette - level.%s) ;relative palette pointer\n' % (levelName, levelName))

  outFile.write('.dw (level.%s.palettestatus - level.%s) ;relative palette pointer\n' % (levelName, levelName))
  for i in range(len(objects)):
    outFile.write('.dw (level.%s.object.%s - level.%s) ;relative object pointer\n' % (levelName, i, levelName))
  outFile.write('.dw level.%s.objectmap  - level.%s ;absolute objectmap pointer\n' % (levelName, levelName))
  outFile.write('.dw level.%s.tilemap ;absolute metatiles pointer\n' % (levelName))
  outFile.write('.db :level.%s.tilemap  ;absolute metatiles pointer\n' % (levelName))

  outFile.write('.dw level.%s.layers ;absolute compressed layers pointer\n' % (levelName))
  outFile.write('.db :level.%s.layers ;absolute compressed layers pointer\n\n' % (levelName))

  outFile.write('level.%s.palette: ;palette data\n %s\n\n' % (levelName, getByteList(bgPaletteStream)))
  if not statusLayer:
    outFile.write('level.%s.palettestatus: ;palette data\n' % (levelName))
  else:
    outFile.write('level.%s.palettestatus: ;palette data\n %s\n\n' % (levelName, getByteList(statusPaletteStream)))  
 

  for i in range(len(objects)):
    outFile.write('\nlevel.%s.object.%s:\n' % (levelName, i))
    outFile.write(' .dw %s.CLS.PTR ;pointer to object class\n' % (objects[i]['class']))
    for parameter in objects[i]['properties']:
      outFile.write(' .dw %s.parameter.%s ;parameter name\n' % (objects[i]['class'], parameter['name']))
      outFile.write(' .dw %s ;parameter value\n' % (parameter['value'] if parameter['value'] else "object.parameter.void"))
  outFile.write('\nlevel.%s.objectmap: ;obsolete, object map data\n .db 0\n.ends\n\n' % (levelName))
  outFile.write('\n.section "level.%s.tilemap" superfree\nlevel.%s.tilemap: ;compressed metatiles\n %s\n.ends\n\n' % (levelName, levelName, getByteList(graconGfx.compress([chr(byte) for byte in getWordByteList(metaLayers['tiles'])]))))
  
  #compressed
  allMaps = metaLayers['layers'][0] + metaLayers['layers'][1]
  if 3 <= len(metaLayers['layers']):
    allMaps += metaLayers['layers'][2]
  if 4 <= len(metaLayers['layers']):
    allMaps += metaLayers['layers'][3]
  
  logging.debug("%s layers, %x tiles" % (len(metaLayers['layers']), len(allMaps) ))

  allMapsBytes = getWordByteList(allMaps)
  allMapsCompressed = graconGfx.compress([chr(byte) for byte in allMapsBytes])
  outFile.write('\n.section "level.%s.layers" superfree\nlevel.%s.layers: ;all compressed layers\n %s\n\n\n' % (levelName, levelName, getByteList(allMapsCompressed)))  

  outFile.write('\n.ends\n\n')
  outFile.write('.ifndef %s.defined\n' % bgTilesetStreamHash)
  outFile.write('.def %s.defined 1\n' % bgTilesetStreamHash)
  outFile.write('.export %s.defined\n' % bgTilesetStreamHash)
  outFile.write('.section %s superfree\n' % bgTilesetStreamHash)

  tileset = bgTilesetStream
  packedTileset = graconGfx.compress(tileset)

  outFile.write('%s: ;packed tile data\n %s\n\n' % (bgTilesetStreamHash, getByteList(packedTileset)))

  outFile.write('%s.end:\n' % bgTilesetStreamHash)
  outFile.write('.ends\n')
  outFile.write('.endif\n')

  if statusLayer:
    outFile.write('.ifndef %s.defined\n' % statusTilesetStreamHash)
    outFile.write('.def %s.defined 1\n' % statusTilesetStreamHash)
    outFile.write('.export %s.defined\n' % statusTilesetStreamHash)

    outFile.write('.section %s superfree\n' % statusTilesetStreamHash)
    
    outFile.write('%s: ;tile data\n %s ;empty tile\n %s\n\n' % (statusTilesetStreamHash, getByteIntList([0 for i in range(singleTileSize)]), getByteList(statusTilesetStream)))

    outFile.write('%s.end:\n' % statusTilesetStreamHash)
    outFile.write('.ends\n')
    outFile.write('.endif\n')
  
  outFile.close()

  if options.get('verify'):
    graconGfx.writeSamplePalette(bgPalette, options)
    graconGfx.writeSampleImage(convertedTileset, bgPalette, inputImage, options)
    graconGfx.writeSampleTileset(convertedTileset, bgPalette, inputImage, options)

  if options.get('dump'):
    dumpBinaryFile(getWordByteList(metaLayers['tiles']), 'metatilelist', options)
    dumpBinaryFile([int(ord(byte)) for byte in bgTilesetStream], 'tile', options)


    for layerId in range(len(metaLayers['layers'])):
      dumpBinaryFile(getWordByteList(metaLayers['layers'][layerId]), ('layer.%s' % layerId), options)

  logging.debug('exiting...')


def dumpBinaryFile(data, name, options):
  try:
    outFileName = '%s.%s' % (options.get('outfile'), name)
    outFile = open(outFileName, 'wb' )
  except IOError:
    logging.error( 'unable to access required output-file %s' % outFileName )
    sys.exit(1)

  [outFile.write(chr(byte)) for byte in data]
  outFile.close()


def getByteList(data):
  return '.db %s' % ','.join([str(ord(byte)) for byte in data])

def getByteIntList(data):
  return '.db %s' % ','.join([("$%x" % byte) for byte in data])
  
def getWordByteList(data):
  output = []
  for byte in data:
      output.append((byte)&0xff)
      output.append(((byte)&0xff00) >> 8 )
  return output

def getWordList(data):
  return '.dw %s' % ','.join([("$%x" % byte) for byte in data])

def getUsedTiles(bgLayers, tileset):
  return set([max(0,(tile & ~(TILED_ID_FLIP_DIAGONAL | TILED_ID_FLIP_X | TILED_ID_FLIP_Y)) - int(tileset['firstgid'])) for layer in bgLayers for tile in layer['data']])

def convertLayerTilemaps(bgLayers, tileset, convertedTileset, palette, options, offset):
  for layerId in range(len(bgLayers)):
    for tileId in range(len(bgLayers[layerId]['data'])):
      #0 denotes empty tile. anything > 0 is a set tile
      tileIdWithFlags = bgLayers[layerId]['data'][tileId]
      tileIdValue = tileIdWithFlags & ~(TILED_ID_FLIP_DIAGONAL | TILED_ID_FLIP_X | TILED_ID_FLIP_Y)
      if 0 != tileIdValue:
        try:
          tile = convertedTileset[tileIdValue - int(tileset['firstgid'])]
          bgLayers[layerId]['data'][tileId] = (graconGfx.fetchTileConfig( tile, convertedTileset, palette )['concatConfig'] + offset) #+1 because of empty tile
          if tileIdWithFlags & TILED_ID_FLIP_DIAGONAL:
            logging.info('Tile rotation unsupported for tile id %s contained in layer %s.' % (tileId, layerId))
          if tileIdWithFlags & TILED_ID_FLIP_Y:
            bgLayers[layerId]['data'][tileId] ^= 1 << 15
          if tileIdWithFlags & TILED_ID_FLIP_X:
            bgLayers[layerId]['data'][tileId] ^= 1 << 14
          #16x16 tiles still use 8x8 tile IDs so they need to be doubled
          #if options.get('tilesizex') == 16:
            #bgLayers[layerId]['data'][tileId] = bgLayers[layerId]['data'][tileId] & 0xFC00 | ((bgLayers[layerId]['data'][tileId] & 0x1ff) << 1)

          if 16 == options.get('tilesizex'):
            #barrel shift left lower 4 bits if tilewidth = 16
            bgLayers[layerId]['data'][tileId] = bgLayers[layerId]['data'][tileId] & 0xFC00 | ((bgLayers[layerId]['data'][tileId] & 0x1ff) << 1)
          if 16 == options.get('tilesizey'):
            #barrel shift left next 4 bits if tileheight = 16
            bgLayers[layerId]['data'][tileId] = bgLayers[layerId]['data'][tileId] & 0xFC0F | ((bgLayers[layerId]['data'][tileId] & 0x1f0) << 1)


        except IndexError:
          logging.info('Tile id %s contained in layer %s not present in tileset, reverting to tile id 0.' % (tileId, layerId))
          bgLayers[layerId]['data'][tileId] = 0
  return bgLayers

def getMetaIndexList(data):
  output = []
  for byte in data:
    for i in range(0,META_TILESIZE):
      output.append("$%x" % ((byte >> (16*i))&0xffff))
  return '.dw %s' % ','.join(output)

def getMetaIndexByteList(data):
  output = []
  for byte in data:
    for i in range(0,META_TILESIZE):
      output.append((byte >> (16*i))&0xff)
      output.append(((byte >> (16*i))&0xff00) >> 8 )
  return output
  
def getLayerData(layerElement):
  data = layerElement.getElementsByTagName('data')[0]
  if not "csv" == data.getAttribute('encoding'):
    logging.error( 'unsupported layer encoding (must be of type "csv")' )
    sys.exit(1)
    
  return {
    'properties' : [],
    'data' : [int(tile) for tile in getDomElementText(data.childNodes).split(',')]
  }

def getDomElementText(nodelist):
    rc = []
    for node in nodelist:
        if node.nodeType == node.TEXT_NODE:
            rc.append(node.data)
    return ''.join(rc)
    
def combineBgLayers(layers):
  newLayers = []
  if 0 < len(layers):
    newLayers.append(layers[0] if 1 == len(layers) else mergeLayers(layers[0], layers[1]))
    if 2 < len(layers):
      newLayers.append(layers[2] if 3 == len(layers) else mergeLayers(layers[2], layers[3]))
  return newLayers

#merge high layer into low, set priority bit
def mergeLayers(layerLo, layerHi):
  for i in range(len(layerLo['data'])):
    if 0 != (layerHi['data'][i] & 0x3ff):
      layerLo['data'][i] = layerHi['data'][i] | 0x2000
  return layerLo

#meta layers contain index of used metatile
def getMetaTiles(layers, width):
  actualTiles = []
  metaLayers = []
  for layer in layers:
    metaLayer = []
    for x in range(int(math.ceil(len(layer['data'])/META_TILESIZE))):
        metatile = 0
        for i in range(0,META_TILESIZE):
          try:
            index = ((x*META_TILESIZE)+i)
            tile = layer['data'][index]
          except IndexError:
            tile = 0
          metatile += (tile << (i*16))         
        if metatile not in actualTiles:
          actualTiles.append(metatile)
        metaLayer.append(actualTiles.index(metatile))
    metaLayers.append(metaLayer)
  return {
    'tiles' : actualTiles,
    'layers' : metaLayers
  }


def getMetaTilesAbsolute(layers, width, noPackIndexes, ModifiableLayers):
  logging.debug("now fetching meta")

  actualTiles = []
  metaLayers = []
  layerID = 0
  for layer in layers:
    logging.debug("meta layer")

    metaLayer = []

    #always fetch full map size because ROM code expects static size meta maps
    for x in range(int(math.ceil(len(layer['data'])/META_TILESIZE))):
        z = x*META_TILESIZE
        bufferIndex = -1
        for i in range(0, len(actualTiles)):
          found = True
          for e in range(0,META_TILESIZE):
            try:
              found = found and (actualTiles[i+e] == layer['data'][z+e]) and not noPackIndexes[z+e]
            except IndexError:
              found = False
              break
            if not found:
              break

          if found == True:
            bufferIndex = i
            break

        if -1 == bufferIndex:
          bufferIndex = len(actualTiles)
          for e in range(0,META_TILESIZE):
            actualTiles.append(layer['data'][z+e])

        metaLayer.append(bufferIndex*2)
    #pad out list to static length:
    #pp.pprint(("completed meta layer length", len(metaLayer)))
    metaLayer += [0] * (0x1000 - len(metaLayer))

    layerID += 1
    metaLayers.append(metaLayer)
  logging.debug("done fetching meta")

  return {
    'tiles' : actualTiles,
    'layers' : metaLayers
  }
#meta layers contain direct pointer into metatile byte buffer, metatiles are 4x4 blocks instead of 16x1 strips.
#enables reusing shifted data
def getMetaTilesAbsoluteBlock(layers, width):
  logging.debug("now fetching meta block")
  actualTiles = []
  metaLayers = []
  metaEdge = int(math.sqrt(META_TILESIZE))
  for layer in layers:

    metaLayer = []
    for y in range(int(math.ceil(len(layer['data'])/width/metaEdge))):
      for x in range(int(math.ceil(width/metaEdge))):    

        metaTileBytes = []
        for ty in range(0,metaEdge):
          for tx in range(0,metaEdge):
            try:
              index = ((x*metaEdge)+tx)+(y*metaEdge*width)+(ty*width)
              tile = layer['data'][index]
            except IndexError:
              tile = 0
            metaTileBytes.append(tile&0xff)
            metaTileBytes.append((tile&0xff00) >> 8 )

        bufferIndex = -1
        bytesStr = str(metaTileBytes)
        #look for identical string of bytes in existing buffer
        for i in range(0, len(actualTiles)):
          targetMeta = str(actualTiles[i:i+(META_TILESIZE*2)])

          if targetMeta == bytesStr:
            bufferIndex = i
        #not found? append to buffer
        if -1 == bufferIndex:
          bufferIndex = len(actualTiles)
          for byte in metaTileBytes:
            actualTiles.append(byte)
        

        metaLayer.append(bufferIndex)
    metaLayers.append(metaLayer)
  logging.debug("done fetching meta")

  return {
    'tiles' : actualTiles,
    'layers' : metaLayers
  }

if __name__ == "__main__":
	main()

